stack layout
                               .
                               .
                               |
                               |
                               |
  frame                        |
    ...                        |
                               |
    [pointer to arg lim+2] ----+
                               |
    [pointer to arg lim+1] ----+

    [pointer to continuation function] <--- stack pointer register


to return:
  new_stack_pointer = base_pointer
  continuation_function = *stack_pointer
  continuation_function(new_stack_pointer)





length : forall a. List a -> Int
length as =
  case as of
    Nil ->
      0

    Cons _ as' ->
      len = length as
      1 + len


length(stack, as, return) {
  switch (tag(as)) {
    0 ->
      continuation = peek(stack)
      *return = 0
      continuation(stack)
    1 ->
      stack1_parent_return = stack.push(return)
      stack2_as' = stack1_parent_return.push(&(*as)[2])
      stack3_return = stack2_as'.push(0)
      stack4_cont = stack3_return.push(length_1)
      length(stack4_cont, stack2_as', stack3_return)
  }
}

length_1(stack4) {
  (stack3, cont) = pop(stack4)
  (stack2, return) = pop(stack3)
  (stack1, _) = pop(stack2)
  (stack, parent_return) = pop(stack1)
  *parent_return = *return + 1
  continuation = peek(stack)
  continuation(stack)
}

length(sp, as, return) {
  switch ((*as)[0]) {
    0 ->
      continuation = *sp
      *return = 0;
      continuation(sp);

    1 ->
      as' = (*as)[2]
      sp' = sp - 24
      *(sp - 8) = return
      *sp' = length_1
      length(sp', as', sp - 16)
  }

}

length_1(sp) {
  result = *(sp - 16)
  return = *(sp - 8)
  sp' = sp + 24;
  *return = result;
  continuation = *sp;
  continuation(sp);
}

---------------------------------------------------------------------------
-- direct return

length(stack, as) {
  switch (tag(as)) {
    0 ->
      continuation = peek(stack)
      continuation(stack, 0)
    1 ->
      stack2 = stack.push(length_1)
      length(stack2, (*as)[2])
  }
}

length_1(stack2, return) {
  (stack, cont) = pop(stack)
  continuation = peek(stack)
  return' = return + 1
  continuation(stack, return')
}

-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------

times : Int -> Int -> Int
times a b =
  if a == 1 then
    b
  else
    b + times (a - 1) b

times(stack, a, b) {
  if a == 1 then
    continuation = peek(stack)
    continuation(stack, b)
  else
    stack2 = stack.push(times_1)
    stack3 = stack2.push(b)
    times (a - 1) b
}

times_1(stack, return) {
  (stack, _) = pop(stack)
  (stack, b) = pop(stack)
  (stack, cont) = pop(stack)
  return' = b + return
  cont(stack, return')
}
